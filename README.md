# C++语言程序设计

《C++语言程序设计》

作者：郑莉 董渊 何江舟

清华大学出版社，2019年出版

## 第四章 类和对象

### 4.1 面向对象程序设计的基本特点

- 抽象：是指对具体问题进行概括，抽象出一类对象的公共属性并加以描述的过程。
  - 数据抽象
  - 行为抽象
- 封装：将抽象到的数据和行为相结合，形成一个有机的整体。
- 继承：在保持原有类特性的基础上，进行更详细的说明。
- 多态：一段程序能处理多种类型对象的能力。
  - 强制多态
  - 重载多态
  - 类型参数化多态
  - 包含多态

### 4.2 类和对象

#### 4.2.1 类的定义
在面向对象程序设计过程中，程序模块是由类构成的。类是对逻辑上相关的函数与数据的封装，它是对问题的抽象描述。其语法形式如下：
```text
class  类名
{
public:
	外部接口
protected:
	保护型成员
private:
	私有成员
};
```

#### 4.2.1 类成员的访问控制

- 共有类型：定义了外部接口。

- 私有类型：只能被**类内成员函数**访问，类外部任何访问都是**非法的**。

- 保护类型：和私有成员性质类似，差别在于继承过程中对**新类**的影响。

> 数据成员应该声明为私有，在书写时公有成员写在最前面。

#### 4.2.3 对象
声明对象 

```text
类名 对象名
```
> 对象所占的内存空间只用于存储**数据成员**，函数成不在每个对象中存放副本，只占据一份空间。

访问数据成员
```text
对象名.数据成员
```

访问函数成员
```text
对象名.函数成员
```
#### 4.2.4 类的成员函数
1.成员函数的实现
函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型。而函数的具体实现是写在类定义之外的。与普通函数不同的是，实现成员函数时要指明类的名称，具体形式为：

```text
返回值类型 类名：：函数成员名（参数表）
{
	函数体
}
```
2.成员函数调用中的目的对象
调用一个成员函数与调用普通函数的差异在于，需要使用“.”操作符指出调用所针对的对象，这一对象在本次调用中称为目的对象。

3.带默认形参值的成员函数
类成员函数的默认值，一定要写在**类定义中**，而不能写在类定义之外的函数实现中。

4.内联函数成员
内联函数的声明有两种方式：隐式声明和显式声明。
- 将函数体直接放在类体内，这种方法称之为隐式声明。
- 为了保证类定义的简洁，可以采用关键字**inline**显式声明的方式。

### 4.3 构造函数与析构函数
在定义对象的时候进行的数据成员设置，称为对象的初始化。C++程序中的初始化和清理工作，分别由两个特殊的成员函数来完成，他们就是构造函数和析构函数。

#### 4.3.1 构造函数
构造函数的作用就是在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态。
```text
class 类名{
public:
	类名();
};
```
构造函数也是一个类的成员函数，除了具有一般成员函数的特征之外，还有以下特殊的性质：
- 构造函数的函数名与类名相同。
- 没有返回值
- 其通常被声明为公有函数。

只要类中有构造函数，编译器就会在建立新对象的地方自动插入对构造函数调用的代码，即构造函数在对象被创建的时候将被**自动调用**。构造函数可以是直接访问所有的数据成员，可以是内联函数，可以带有参数表，可以带默认值，可以重载。

无需提供参数的构造函数称为默认构造函数，如果没写构造函数，系统默认生成一个隐含的构造函数，参数列表和函数体均为空。 如果定义了构造函数，编译器不会生成隐含的默认构造函数。


#### 4.3.2 复制构造函数
复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是本类对象的引用，其作用是使用一个已经存在的对象（由复制构造函数的参数指定），去初始化同类的一个新对象。语法形式如下：
```text
class 类名{
public:
	类名();
    类名(类名 &对象);
};
```
如果没有定义类的构造函数，系统会自动生成一个隐含的复制构造函数，这个隐含的复制构造函数的作用是把初始值对象的每一个数据成员的值都复制到新建立的对象。

复制构造函数在以下情况会被默认调用
```c++
//函数形参是类的对象
void fun1(Point p)
{
	cout << p.getX() << endl;
}
//函数返回值是类的对象
Point fun2()
{
	Point a(1, 2);//会消亡
	return a;
}
```

- 用类来初始化该类的另一个对象时
```c++
Point a(4, 5);

// 类的一个对象初始化另一个对象
Point b(a);
Point c = a;
cout << b.getX() << "\t" << c.getX() << endl;//4       4
```
- 函数的形参是类的对象
```c++
//函数形参是类的对象
fun1(b); //4
```
- 函数的返回值是类的对象
```c++
//函数返回值是类的对象
b = fun2();
cout << b.getX() << endl;//1
```
#### 4.3.3 析构函数

析构函数用来完成对象被删除前的一些清理工作。析构函数是在对象生存期即将结束时的时刻被**自动调用**的。析构函数通常也是类的一个公有函数成员，它的名称是由类名前面加“~”构成，没有返回值，且不接收任何参数。其语法形式如下：

```text
class 类名{
public:
	~类名();
};
```
不进行显示说明，系统自动生成一个函数体为空的而隐含析构函数，如果人们希望对象被删除之前时刻西东完成某些事情，就可以将他们把他们写进析构函数中。

### 4.4 类的组合

#### 4.4.1 组合
类的组合描述即使一个类内嵌其他类的对象做为成员。当创建类的时候，如果这个类具有内嵌对象成员，那么这个内嵌对象成员将首先被自动创建。创建对象时，既要对本类的基本数据类型进行初始化，也要对内嵌对象成员进行初始化。其定义形式：

```text
类名::类名(形参表):内嵌对象1(形参表),内嵌对象2(形参表)...
{
	类的初始化
}
```
> 其中 内嵌对象1(形参表),内嵌对象2(形参表)... 被称为初始化列表，可以对内嵌对象初始化


构造函数的调用顺序如下：

调用内嵌对象的构造函数，调用顺序按照**内嵌对象在组合类中的定义中出现的次序**。内嵌对象在构造函数的初始化列表中出现的顺序与内嵌对象构造函数的调用顺序**无关**。执行本类构造函数的函数体。析构函数的执行顺序与构造函数刚好相反

### 4.6 结构体和联合体

#### 4.6.1 结构体

结构体是一种特殊形态的类。结构体和类的唯一区别在于，结构体和类具有不同的默认访问控制属性：在类中，对于未指定访问控制属性的成员，其访问控制属性为**私有类型**；在结构体中，对于未指定访问控制属性的成员，其访问控制属性为**公有类型**。

#### 4.6.2 联合体

联合体是一种特殊形态的类。它可以有自己的数据成员和函数成员，与结构体一样也是从C语言继承过来的。联合体的全部数据成员**共享同一组内存单元**。

## 第五章 数据的共享与保护

### 5.1 标识符的作用域与可见性
#### 5.1.1 作用域
作用域是一个标识符在程序正文中的有效的区域，C++中标识符的作用域：**函数原型作用域、局部作用域（块作用域）、类作用域、文件作用域、命名空间作用域**
1. 函数原型的作用域 
在函数原型声明时形式参数的作用范围就是函数原型作用域。
2. 局部作用域（块作用域）
函数体内声明的变量，其作用域从声明处开始，一直到声明所在块结束的大括号为止。
3. 类作用域
类可以被看成一组由名成员的集合，类X的成员具有类作用域，对m的访问有如下3种方式：
- 如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m
- 访问对象成员 X.m 或 X::m（访问类中静态成员）
- ptr->m（ptr为指向对象的一个指针）
4. 命名空间作用域
为了避免重名冲突，使编译器能够区分来自不同库的同名实体，将不同的标识符集合在一个命名作用域（named space）内，是全局作用域的细分，本质上定义了实体所属的空间，一个命名空间确定了一个命名空间作用域。语法形式如下：
```text
namespace namespace_name{
	//代码声明
}
```
使用某个命名空间中的函数、变量等实体，需要如下方法：
```text
命名空间::实体名称 
```
为了解决命名空间显得过于冗长，用using来指定命名空间：
```text
using 命名空间名::标志符名;
using namespace 命名空间名;
```
前一种形式将指定的标识符暴露在当前的作用域内，使得在当前作用域中可以直接引用该标识符；后一种形式将指定命名空间内的所有标识符暴露在当前的作用域内。

具有命名空间作用域的变量也称为全局变量。

#### 5.1.2可见性
从标识符引用的角度来看标识符的有效范围，即标识符是否可以被引用。表示从内层作用域向外层作用域“看”时能看见什么，如果标识符在某处可见，则就可以在该处引用此标识符。可见性的规则如下：
- 标识符要先声明，后使用
- 在同一作用域中，不能声明同名的标识符（重载函数除外)
- 在没有相互包含关系的不同的作用域中声明的同名标识符，互不影响
- 如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见
- 如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层中可见


### 5.2对象的生存期
对象从产生到结束的这段时间就是它的生存期，在对象的生存期内，对象将保持它的值（数据成员的值），直到被更新为止。

#### 5.2.1静态生存期
静态生存期：如果对象的生存期与程序运行的生存期相同，我们就称它具有静态生存期，如果要在函数内部的局部作用域中声明具有静态生存期的对象，则要使用**static**关键字。

局部作用域中静态变量地特点是，它并不会随着每次函数调用而产生一个副本，也不会随着函数返回而失效。

> 定义时未指定初值的基本类型静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定。另，若定义数组时未初始化，初值也不确定；若定义数组时初值个数少于数组大小，其余自动为0。

#### 5.2.2动态生存期
除了以上两种情况，其余的对象都具有动态生存期，称为局部生存期对象。局部生存期对象诞生于声明点，结束语声明所在的块执行完毕之时。
### 5.3 类的静态成员
#### 5.3.1 静态数据成员
如果某个属性为整个类所共有，不属于任何一个对象，则采用**static**关键字来声明为静态成员。静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一类的不同对象之间的数据共享。

**静态数据成员具有静态生存期**。由于静态数据成员不属于任何一个对象，因此可以通过类名对它进行访问，一般的用法是**“类名::标识符”**。在类的定义中只对静态数据成员进行引用性声明，然后在命名空间作用域中必须使用类名进行定义性声明。之所以类的静态数据成员需要在类定义之外再加以定义，是因为需要以这种方式专门为它们分配空间。

#### 5.3.2 静态函数成员
就是使用**static**关键字声明的函数成员，性质与静态数据成员一样。静态成员函数可以直接访问该类的**静态数据**和**函数成员**，而访问非静态成员必须通过对象名。因此通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要用来访问同一个类中的静态数据成员，维护对象之间共享的数据。
### 5.4 类的友元
友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通俗来说，友元关系就是一个类主动声明哪些其他类或函数是它的朋友，进而给它们提供对本类的访问特许。从一定程度上来讲，友元是对数据隐蔽和封装的破坏。

友元类的所有成员函数都自动成为友元函数。
#### 5.4.1 友元函数
友元函数是在类中用关键字**friend**修饰的非成员函数。友元函数可以是一个普通的函数，也可以是其他类的成员函数。虽然它不是本类的成员函数，但是**在它的函数体中可以通过对象名访问类的私有和保护成员**。

### 5.4.2 友元类
若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员。声明的语法形式为：
```text
class B{
    ...
    friend class A;//声明A为B的友元类
    ...
};
```

关于友元，还有几点需要注意：

- 友元关系是不能传递的。

- 友元关系是单向的。

- 友元关系是不能继承的。

### 5.5 共享数据的保护
对于既需要共享又需要防止改变的数据应该声明为常量。常量的重要特性：必须初始化，而且不能被更新。

#### 5.5.1 常对象
它的数据成员值在对象的整个生存期间不能被改变，常对象必须初始化，而且不能被更新。其语法形式如下：
```text
const 类型说明符 对象名;
```
两个途径：
- 直接访问：通过对象名访问数据成员。常对象的数据成员被视为常量，通过常对象访问数据成员不允许被复制
- 间接访问：通过成员函数改变数据成员。不能通过常对象调用普通成员函数，常对象只能调用常成员函数

#### 5.5.2 用const修饰的类成员
1. 常函数
不会改变目的对象的数据成员的值；声明格式如下：
```text
类型说明符 函数名(参数表) const
```
注意事项
- const是函数类型的一个组成部分，因此在函数的定义部分也要带**const**关键字

- 如果将一个对象说明为常对象，则通过该常对象只能调用它的**常成员函数**，而不能调用其他成员函数

- 无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都被视同为常对象，因此常成员函数不能更改目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了在常成员函数中不会更改目的对象的数据成员的值）。

- const关键字可以用于对重载函数的区分
> 如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的函数——不带const关键字的函数。
对于无须改变对象状态的成员函数，都应当使用**const**


2. 常数据成员
类的成员数据可以使常量，使用**const**说明，如果在一个类中声明了常数据成员，那么任何函数都不能对该成员赋值，构造函数对常数据成员的初始化，只能通过构造函数的**初始化列表**。

#### 5.5.3 常引用
引用的对象不能更新，且自动化为常对象，声明形式如下：
```text
const 类型说明符 &引用名;
```

常引用做形参：为了追求高效率，且不双向传递。对于在函数中无需改变其值的参数，不宜使用普通引用方式传递，因为那会使得常对象无法被传入，采用传值方式或传递常引用的方式可避免这一问题，复制构造函数的参数一般也宜采用**常引用传递**。
