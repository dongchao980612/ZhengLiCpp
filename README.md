# C++语言程序设计

《C++语言程序设计》

作者：郑莉 董渊 何江舟

清华大学出版社，2019年出版

## 第四章 类和对象

### 4.1 面向对象程序设计的基本特点

- 抽象：是指对具体问题进行概括，抽象出一类对象的公共属性并加以描述的过程。
  - 数据抽象
  - 行为抽象
- 封装：将抽象到的数据和行为相结合，形成一个有机的整体。
- 继承：在保持原有类特性的基础上，进行更详细的说明。
- 多态：一段程序能处理多种类型对象的能力。
  - 强制多态
  - 重载多态
  - 类型参数化多态
  - 包含多态

### 4.2 类和对象

#### 4.2.1 类的定义
在面向对象程序设计过程中，程序模块是由类构成的。类是对逻辑上相关的函数与数据的封装，它是对问题的抽象描述。其语法形式如下：
```text
class  类名
{
public:
	外部接口
protected:
	保护型成员
private:
	私有成员
};
```

#### 4.2.1 类成员的访问控制

- 共有类型：定义了外部接口。

- 私有类型：只能被**类内成员函数**访问，类外部任何访问都是**非法的**。

- 保护类型：和私有成员性质类似，差别在于继承过程中对**新类**的影响。

> 数据成员应该声明为私有，在书写时公有成员写在最前面。

#### 4.2.3 对象
声明对象 

```text
类名 对象名
```
> 对象所占的内存空间只用于存储**数据成员**，函数成不在每个对象中存放副本，只占据一份空间。

访问数据成员
```text
对象名.数据成员
```

访问函数成员
```text
对象名.函数成员
```
#### 4.2.4 类的成员函数
1.成员函数的实现
函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型。而函数的具体实现是写在类定义之外的。与普通函数不同的是，实现成员函数时要指明类的名称，具体形式为：

```text
返回值类型 类名：：函数成员名（参数表）
{
	函数体
}
```
2.成员函数调用中的目的对象
调用一个成员函数与调用普通函数的差异在于，需要使用“.”操作符指出调用所针对的对象，这一对象在本次调用中称为目的对象。

3.带默认形参值的成员函数
类成员函数的默认值，一定要写在**类定义中**，而不能写在类定义之外的函数实现中。

4.内联函数成员
内联函数的声明有两种方式：隐式声明和显式声明。
- 将函数体直接放在类体内，这种方法称之为隐式声明。
- 为了保证类定义的简洁，可以采用关键字**inline**显式声明的方式。

### 4.3 构造函数与析构函数
在定义对象的时候进行的数据成员设置，称为对象的初始化。C++程序中的初始化和清理工作，分别由两个特殊的成员函数来完成，他们就是构造函数和析构函数。

#### 4.3.1 构造函数
构造函数的作用就是在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态。
```text
class 类名{
public:
	类名();
};
```
构造函数也是一个类的成员函数，除了具有一般成员函数的特征之外，还有以下特殊的性质：
- 构造函数的函数名与类名相同。
- 没有返回值
- 其通常被声明为公有函数。

只要类中有构造函数，编译器就会在建立新对象的地方自动插入对构造函数调用的代码，即构造函数在对象被创建的时候将被**自动调用**。构造函数可以是直接访问所有的数据成员，可以是内联函数，可以带有参数表，可以带默认值，可以重载。

无需提供参数的构造函数称为默认构造函数，如果没写构造函数，系统默认生成一个隐含的构造函数，参数列表和函数体均为空。 如果定义了构造函数，编译器不会生成隐含的默认构造函数。


#### 4.3.2 复制构造函数
复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是本类对象的引用，其作用是使用一个已经存在的对象（由复制构造函数的参数指定），去初始化同类的一个新对象。语法形式如下：
```text
class 类名{
public:
	类名();
    类名(类名 &对象);
};
```
如果没有定义类的构造函数，系统会自动生成一个隐含的复制构造函数，这个隐含的复制构造函数的作用是把初始值对象的每一个数据成员的值都复制到新建立的对象。

复制构造函数在以下情况会被默认调用
```c++
//函数形参是类的对象
void fun1(Point p)
{
	cout << p.getX() << endl;
}
//函数返回值是类的对象
Point fun2()
{
	Point a(1, 2);//会消亡
	return a;
}
```

- 用类来初始化该类的另一个对象时
```c++
Point a(4, 5);

// 类的一个对象初始化另一个对象
Point b(a);
Point c = a;
cout << b.getX() << "\t" << c.getX() << endl;//4       4
```
- 函数的形参是类的对象
```c++
//函数形参是类的对象
fun1(b); //4
```
- 函数的返回值是类的对象
```c++
//函数返回值是类的对象
b = fun2();
cout << b.getX() << endl;//1
```
#### 4.3.3 析构函数

析构函数用来完成对象被删除前的一些清理工作。析构函数是在对象生存期即将结束时的时刻被**自动调用**的。析构函数通常也是类的一个公有函数成员，它的名称是由类名前面加“~”构成，没有返回值，且不接收任何参数。其语法形式如下：

```text
class 类名{
public:
	~类名();
};
```
不进行显示说明，系统自动生成一个函数体为空的而隐含析构函数，如果人们希望对象被删除之前时刻西东完成某些事情，就可以将他们把他们写进析构函数中。

### 4.4 类的组合

#### 4.4.1 组合
类的组合描述即使一个类内嵌其他类的对象做为成员。当创建类的时候，如果这个类具有内嵌对象成员，那么这个内嵌对象成员将首先被自动创建。创建对象时，既要对本类的基本数据类型进行初始化，也要对内嵌对象成员进行初始化。其定义形式：

```text
类名::类名(形参表):内嵌对象1(形参表),内嵌对象2(形参表)...
{
	类的初始化
}
```
> 其中 内嵌对象1(形参表),内嵌对象2(形参表)... 被称为初始化列表，可以对内嵌对象初始化


构造函数的调用顺序如下：

调用内嵌对象的构造函数，调用顺序按照**内嵌对象在组合类中的定义中出现的次序**。内嵌对象在构造函数的初始化列表中出现的顺序与内嵌对象构造函数的调用顺序**无关**。执行本类构造函数的函数体。析构函数的执行顺序与构造函数刚好相反

### 4.6 结构体和联合体

#### 4.6.1 结构体

结构体是一种特殊形态的类。结构体和类的唯一区别在于，结构体和类具有不同的默认访问控制属性：在类中，对于未指定访问控制属性的成员，其访问控制属性为**私有类型**；在结构体中，对于未指定访问控制属性的成员，其访问控制属性为**公有类型**。

#### 4.6.2 联合体

联合体是一种特殊形态的类。它可以有自己的数据成员和函数成员，与结构体一样也是从C语言继承过来的。联合体的全部数据成员**共享同一组内存单元**。

## 第五章 数据的共享与保护

### 5.1 标识符的作用域与可见性
#### 5.1.1 作用域
作用域是一个标识符在程序正文中的有效的区域，C++中标识符的作用域：**函数原型作用域、局部作用域（块作用域）、类作用域、文件作用域、命名空间作用域**
1. 函数原型的作用域 
在函数原型声明时形式参数的作用范围就是函数原型作用域。
2. 局部作用域（块作用域）
函数体内声明的变量，其作用域从声明处开始，一直到声明所在块结束的大括号为止。
3. 类作用域
类可以被看成一组由名成员的集合，类X的成员具有类作用域，对m的访问有如下3种方式：
- 如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m
- 访问对象成员 X.m 或 X::m（访问类中静态成员）
- ptr->m（ptr为指向对象的一个指针）
4. 命名空间作用域
为了避免重名冲突，使编译器能够区分来自不同库的同名实体，将不同的标识符集合在一个命名作用域（named space）内，是全局作用域的细分，本质上定义了实体所属的空间，一个命名空间确定了一个命名空间作用域。语法形式如下：
```text
namespace namespace_name{
	//代码声明
}
```
使用某个命名空间中的函数、变量等实体，需要如下方法：
```text
命名空间::实体名称 
```
为了解决命名空间显得过于冗长，用using来指定命名空间：
```text
using 命名空间名::标志符名;
using namespace 命名空间名;
```
前一种形式将指定的标识符暴露在当前的作用域内，使得在当前作用域中可以直接引用该标识符；后一种形式将指定命名空间内的所有标识符暴露在当前的作用域内。

具有命名空间作用域的变量也称为全局变量。

#### 5.1.2可见性
从标识符引用的角度来看标识符的有效范围，即标识符是否可以被引用。表示从内层作用域向外层作用域“看”时能看见什么，如果标识符在某处可见，则就可以在该处引用此标识符。可见性的规则如下：
- 标识符要先声明，后使用
- 在同一作用域中，不能声明同名的标识符（重载函数除外)
- 在没有相互包含关系的不同的作用域中声明的同名标识符，互不影响
- 如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见
- 如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层中可见


### 5.2对象的生存期
对象从产生到结束的这段时间就是它的生存期，在对象的生存期内，对象将保持它的值（数据成员的值），直到被更新为止。

#### 5.2.1静态生存期
静态生存期：如果对象的生存期与程序运行的生存期相同，我们就称它具有静态生存期，如果要在函数内部的局部作用域中声明具有静态生存期的对象，则要使用**static**关键字。

局部作用域中静态变量地特点是，它并不会随着每次函数调用而产生一个副本，也不会随着函数返回而失效。

> 定义时未指定初值的基本类型静态生存期变量，会被赋予0值初始化，而对于动态生存期变量，不指定初值意味着初值不确定。另，若定义数组时未初始化，初值也不确定；若定义数组时初值个数少于数组大小，其余自动为0。

#### 5.2.2动态生存期
除了以上两种情况，其余的对象都具有动态生存期，称为局部生存期对象。局部生存期对象诞生于声明点，结束语声明所在的块执行完毕之时。
### 5.3 类的静态成员
#### 5.3.1 静态数据成员
如果某个属性为整个类所共有，不属于任何一个对象，则采用**static**关键字来声明为静态成员。静态成员在每个类只有一个副本，由该类的所有对象共同维护和使用，从而实现了同一类的不同对象之间的数据共享。

**静态数据成员具有静态生存期**。由于静态数据成员不属于任何一个对象，因此可以通过类名对它进行访问，一般的用法是**“类名::标识符”**。在类的定义中只对静态数据成员进行引用性声明，然后在命名空间作用域中必须使用类名进行定义性声明。之所以类的静态数据成员需要在类定义之外再加以定义，是因为需要以这种方式专门为它们分配空间。

#### 5.3.2 静态函数成员
就是使用**static**关键字声明的函数成员，性质与静态数据成员一样。静态成员函数可以直接访问该类的**静态数据**和**函数成员**，而访问非静态成员必须通过对象名。因此通过静态函数成员访问非静态成员是相当麻烦的，一般情况下，它主要用来访问同一个类中的静态数据成员，维护对象之间共享的数据。
### 5.4 类的友元
友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通俗来说，友元关系就是一个类主动声明哪些其他类或函数是它的朋友，进而给它们提供对本类的访问特许。从一定程度上来讲，友元是对数据隐蔽和封装的破坏。

友元类的所有成员函数都自动成为友元函数。
#### 5.4.1 友元函数
友元函数是在类中用关键字**friend**修饰的非成员函数。友元函数可以是一个普通的函数，也可以是其他类的成员函数。虽然它不是本类的成员函数，但是**在它的函数体中可以通过对象名访问类的私有和保护成员**。

### 5.4.2 友元类
若A类为B类的友元类，则A类的所有成员函数都是B类的友元函数，都可以访问B类的私有和保护成员。声明的语法形式为：
```text
class B{
    ...
    friend class A;//声明A为B的友元类
    ...
};
```

关于友元，还有几点需要注意：

- 友元关系是不能传递的。

- 友元关系是单向的。

- 友元关系是不能继承的。

### 5.5 共享数据的保护
对于既需要共享又需要防止改变的数据应该声明为常量。常量的重要特性：必须初始化，而且不能被更新。

#### 5.5.1 常对象
它的数据成员值在对象的整个生存期间不能被改变，常对象必须初始化，而且不能被更新。其语法形式如下：
```text
const 类型说明符 对象名;
```
两个途径：
- 直接访问：通过对象名访问数据成员。常对象的数据成员被视为常量，通过常对象访问数据成员不允许被复制
- 间接访问：通过成员函数改变数据成员。不能通过常对象调用普通成员函数，常对象只能调用常成员函数

#### 5.5.2 用const修饰的类成员
1. 常函数
不会改变目的对象的数据成员的值；声明格式如下：
```text
类型说明符 函数名(参数表) const
```
注意事项
- const是函数类型的一个组成部分，因此在函数的定义部分也要带**const**关键字

- 如果将一个对象说明为常对象，则通过该常对象只能调用它的**常成员函数**，而不能调用其他成员函数

- 无论是否通过常对象调用常成员函数，在常成员函数调用期间，目的对象都被视同为常对象，因此常成员函数不能更改目的对象的数据成员，也不能针对目的对象调用该类中没有用const修饰的成员函数（这就保证了在常成员函数中不会更改目的对象的数据成员的值）。

- const关键字可以用于对重载函数的区分
> 如果仅以const关键字为区分对成员函数重载，那么通过非const的对象调用该函数，两个重载的函数都可以与之匹配，这时编译器将选择最近的函数——不带const关键字的函数。
对于无须改变对象状态的成员函数，都应当使用**const**


2. 常数据成员
类的成员数据可以使常量，使用**const**说明，如果在一个类中声明了常数据成员，那么任何函数都不能对该成员赋值，构造函数对常数据成员的初始化，只能通过构造函数的**初始化列表**。

#### 5.5.3 常引用
引用的对象不能更新，且自动化为常对象，声明形式如下：
```text
const 类型说明符 &引用名;
```

常引用做形参：为了追求高效率，且不双向传递。对于在函数中无需改变其值的参数，不宜使用普通引用方式传递，因为那会使得常对象无法被传入，采用传值方式或传递常引用的方式可避免这一问题，复制构造函数的参数一般也宜采用**常引用传递**。



## 第六章  数组、指针与字符串

### 6.1 数组

数组是具有一定顺序关系的若干对象的集合体，组成数组的对象称为该数组的元素。

#### 6.1.1 数组的声明与使用
1. 数组的声明
声明一个数组类型，应包括一下几个方面：
- 数组的名称
- 数组元素的类型
- 数组的结构(数组维数，每一维的大小等)

数组类型声明的一般形式：
```text
数据类型 标识符[常量表达式1][常量表达式2]...;	
```
数组中同类型数据的类型由**数据类型**给出，这个**数据类型**可以是整形、浮点型等基本类型，也可以是结构体、类等用户自定义类型。**标识符**指定数组名称。**[常量表达式1] \[常量表达式2]...**称为数组的界，必须是在编译时就可求出的常量表达式，其值必须为正整数。有n个下标的数组称为n维数组。数组的下标的个数称为数组的维数。二维数组被当作一维数组的数组，更高维数组也如此。
> 数组元素个数是各个下标表达式的乘积
2. 数组的使用

使用数组时只能分别对数组的各个元素操作，数组元素通过下标区分，使用形式如下:
```text
数组名[下标表达式1][下标表达式2]...
```
在使用过程中应注意一下两点：
- 数组元素下标可以是任何合法的算术表达式，但其结果必须是**整数**。
- 数组元素下标值不得超过所声明的上下界，否则运行时会出现数组越界错误。
#### 6.1.2 数组的存储与初始化
1. 数组的存储
数组元素在内存中是顺序、连续存储的。

2. 数组的初始化
数组元素的初始化就是在声明数组时对部分或全部元素赋初值。
若定义数组时没有指定任何一个元素的初值，对于静态生存期的数组，每个元素仍然会被赋值为0，但对于动态生存期的数组，每个元素的初值都是不确定的。
> 给出全部的元素，则第一维的下标个数可以不用显式说明，也可以按照第一位下标进行分组，使用花括号将每一组的数据括起来。
```c++
int a[2][3]={1,0,0,0,1,0};

//等价于
int a[][3]={1,0,0,0,1,0};

int a[2][3]={{1,0,0},{0,1,0}};

int a[][3]={{1,0,0},{0,1,0}};
```
#### 6.1.3 数组作为函数参数
使用数组名传递参数时，传递的是**地址**，实参数组的个数不应少于形参数组的个数，如果在被调函数中对形参数组元素值进行改变，主调函数中实参数组的相应元素值也会改变。
> 数组作为参数时，一般不指定第一维的大小，即使指定，也会被忽略。

#### 6.1.4 对象数组
对象数组的元素是类的**对象**，具有数据成员和函数成员。声明一个一维对象数组形式：
```text
类名 数组名[常量表达式];
```
通过对象数组中元素对象访问公有成员，形式如下：
```text
数组名[下标表达式].成员名
```
数组对象的初始化过程，实际上就是调用构造函数来对每一个元素对象进行初始化。如果在声明数组时给每一个数组元素指定初始值，在数组初始化过程中就会调用与形参类型相匹配的构造函数。

### 6.2 指针

指针是C++从C中继承过来的重要数据类型，提供了一种较为直接的地址操作手段。动态内存分配和管理离不开指针。
#### 6.2.1 内存空间的访问方式
具有静态生存期的变量在程序开始运行之前就被分配了内存空间。具有动态生存期的变量是在程序运行时，遇到变量声明语句时被分配内存空间的。有时使用变量名访问内存空间不够方便，或者根本没有变量名可用，这时就需要直接用地址来访问内存单元。

#### 6.2.2 指针变量的声明
指针是一种数据类型。指针变量用于存放内存单元地址。声明指针的语法形式：
```text
数据类型 *标识符;
```
指针可以指向各种类型，包括基本类型、数组（数据元素）、函数、对象、指针。
#### 6.2.3 与地址相关的运算“*”和“&”
“*”称为指针运算符，也称解析，表示获取指针所指的变量的值，是一元操作符。

“&”称为取地址运算符，用于得到一个对象的（存储单元）地址，是一元操作符。

“*”和“&”出现在声明语句中和执行语句中，其含义是不同的。作为一元运算符和二元运算符时含义也不同。

- （1）在声明语句中的一元运算符“*”和“&”

一元运算符“*”出现在声明语句中，在被声明的变量之前时，表示声明的是指针。

一元运算符“&”出现在声明语句中，在被声明的变量之前时，表示声明的是引用。

- （2）在非声明语句中的一元运算符“*”和“&”

一元运算符“*”出现在执行语句中，或在声明语句的初始化表达式中时，表示访问指针所指对象的内容。

 一元运算符“&”出现在执行语句中，或在给变量赋值时出现在等号右边时，表示取对象的地址。

#### 6.2.4 指针的赋值
定义指针后必须先赋值，然后才能引用。两种赋值方法：

（1）定义指针的同时进行初始化赋值：

```text
存储类型 数据类型 *指针名=初始地址;	//定义指针的同时进行初始化赋值
```

（2）定义指针后，单独使用赋值语句：

```text
指针名=地址;		//定义指针后，单独使用的赋值语句
```

如果使用对象的地址作为指针的初值，或在赋值语句中将对象地址赋给指针变量，该对象必须在赋值之前就声明过，而且这个对象的类型应该和指针类型一致。多个指针可指向同一个变量。

一个数组，可以用它的名称来直接表示它的起始地址。**数组名实际上就是一个不能被赋值的指针，即指针常量。**如：

```c++
int a[10];		//定义int型数组
int *ptr=a;		//定义并初始化int指针
```

关于指针的类型，还应注意：

（1）可以声明指向常量的指针，此时所指对象的值不变，指针本身可变（可指向另外的对象）：

```c++
int a;
const int *p1=&a;	//p1是常量指针
```

（2）可以声明指针类型的常量（指针常量），这时指针本身（的值，为地址）不能被改变：

```c++
int *const p2=&a;	//p2是指针常量
```

（3）一般情况下，指针的值只能赋给相同类型的指针。但void类型的指针，可以存储任何类型的对象地址，任何类型的指针都可以赋值给void类型的指针变量。经过使用类型显示转换，通过void类型的指针便可以访问任何类型的数据。void指针一般只在指针所指向的数据类型不确定时使用。


#### 6.2.5 指针运算
指针与整数加减、指针自增自减都表示移动指针所指位置。

*(p1+n1)可写作p1[n1]，都表示p1当前所指位置后方第n1个数的内容。类似也有*(p1-n1)，可写作p1[-n1]。

慎用指针的算术运算：对指针进行算术运算时，一定要确保运算结果所指向的地址是程序中分配使用的地址。

两个相同类型的指针相等，表示指向的是同一地址。

不同类型的指针之间或指针与非0整数之间的关系运算是无意义的。

但指针变量可以和整数0作比较，0专用于表示**空指针**，即一个不指向任何有效地址的指针。给一个指针变量赋值为0，表示该指针是一个空指针，不指向任何地址。

```c++
int *p;		//声明一个int类型的指针p
p=0;		//将p设置为空指针，不指向任何地址
```

除0以外，赋给指针变量的值不能是其他整数，必须是地址常量（如数组名）或地址变量。空指针也可以用NULL来表示。如果不便于用一个有效地址给一个指针变量赋初值，那么应当用0作为它的初值，从而避免指向不确定地址的指针出现。

```c++
int *p=NULL;	//将int型的指针初始化为空指针
```

> NULL是一个在很多头文件中都有定义的宏，被定义为0。



#### 6.2.6 用指针处理数组元素

把数组作为函数的形参，等价于把指向数组元素类型的指针作为形参。例如，下面三种写法出现在形参列表中是等价的：

```c++
void f(int p[]);
void f(int p[3]);
void f(int *p);
```
> a[i]	*(pa+i)	*(a+i)	pa[i]都是等价的

#### 6.2.7 指针数组

指针数组：如果一个数组的每个元素都是指针变量，这个数组就是指针数组。指针数组的每一个元素都必须是同一类型的指针。声明一维指针数组的语法形式如下：
```text
数据类型 *数组名[下标表达式];	//声明一维指针数组，指针数组的每个元素都是指针变量
```
数组名是指针数组的名称，同时也是这个数组的首地址。由于指针数组的每个元素都是一个指针，必须先赋值后引用，因此声明指针数组必须赋初值。


#### 6.2.8 用数组作为函数参数
如果以指针作为函数的形参，在调用时实参将值传递给形参，也就是使实参和形参指针变量指向同一个内存地址。这样在子函数运行过程中，通过形参指针对数据值的改变会影响实参指针所指向的数据值。

在C语言中，用指针作为函数的形参有三个作用：

1. 使形参和实参指向相同的内存空间，以达到参数双向传递的目的，即通过在被调函数中直接处理主调函数中的数据，来将函数的处理结果返回其调用者。C++中用引用实现这一功能（见第3章）。

2. 减少函数调用时数据传递的开销。C++中有时可用引用实现这一功能，有时还是需要用指针。

3. 通过指向函数的指针传递函数代码的首地址。

> 注意：如果函数体中不需要通过指针改变指针所指对象的内容，应在参数表中将其声明为指向常量的指针，这样使得常对象被取地址后也可作为该函数的参数。

在设计程序时，当某个函数中以指针或引用作为形参都可以达到同样的目的时，使用引用可以使程序的可读性更好些。

#### 6.2.9 指针型函数
指针可以作为函数的返回值。当一个函数的返回值为指针类型时，这个函数就是指针型函数。最主要的目的是在函数结束时**把大量的数据从被调函数返回到主调函数中**。而通常非指针型函数调用结束后，只能返回一个变量或对象。指针型函数的定义如下：

```text
数据类型 *函数名(参数表){		//定义指针型函数
    函数体					//返回值为指针类型
}
```

#### 6.2.10 指向函数的指针（函数指针）
函数指针是专门用来存放函数代码首地址的变量。调用函数的通常形式**“函数名(参数表)”**的实质就是**“函数代码首地址(参数表)”**。一旦函数指针指向了某个函数，它与函数名便具有同样的作用。可以像使用函数名一样使用指向函数的指针来调用函数。函数指针的声明如下：

```text
数据类型 (*函数指针名)(形参表)	//声明函数指针
```
数据类型说明指针所指函数的返回值类型，第一个圆括号中的内容知名一个函数指针的名称；形参表则列出该指针所指函数的形参类型和个数。

由于对函数指针的定义在形式上比较复杂，如果在程序中出现多个这样的定义，多次重复这样的定义相当繁琐，可以使用**typedef**来进行重命名
```c++
typedef int(*DoubleIntFunction)(double);
DoubleIntFunction funcPtr;
```
函数指针在使用前要先赋值，使指针指向一个已经存在的函数代码的起始地址，语法形式如下：
```text
函数指针名=函数名;
```
#### 6.2.11 对象指针

1. 对象指针的一般概念
对象指针是用于存放对象地址的变量。对象所占据的内存空间只是用于存放数据成员的，函数成员不在每一个对象中存储副本。对象指针声明形式如下：

```text
类名 *对象指针名;
```
可以通过对象指针访问对象的成员，语法形式为：

```text
对象指针名->成员名  //通过对象指针访问对象的成员
(*对象指针名).成员名	//上一行的等价形式
```
2. this指针
this指针是一个隐含于每一个**类的非静态成员函数（包括构造函数和析构函数）**中的特殊指针。类的静态成员函数中没有this指针。

this指针用于指向正在被成员函数操作的对象。

this指针实际上是类成员函数的一个隐含参数。在调用类的成员函数时，目的对象的地址会自动作为this指针的值，传递给被调用的成员函数，这样被调函数就能够通过this指针来访问目的对象的数据成员。

this是一个指针常量，对于常成员函数，this同时又是一个指向常量的指针。

在成员函数中，可以使用**this**来标识正在调用该函数的对象。

当局部作用域中声明了与类成员同名的标识符时，对该标识符的直接引用代表的是局部作用域中所声明的标识符，这时，为了访问该类的成员，可以通过this指针（比如this->x）。

3. 指向类的非静态成员的指针
可将类的成员（变量、函数、对象等）的地址存放到一个指针变量中，这样，可以通过这些指针直接访问对象的成员。
指向类的成员的指针声明形式如下：

```text
类型说明符 类名::*指针名;	//声明指向数据成员的指针
类型说明符 (类名::*指针名)(参数表);	//声明指向函数成员的指针
```

对指向类的成员的指针赋值：

```text
指针名=&类名::数据成员名;		//对数据成员指针赋值
指针名=&类名::函数成员名;		//对函数成员指针赋值
```

通过指向类的成员的指针（以及对象指针）访问成员：

```text
对象名.*类数据成员指针名						//访问类的数据成员
对象指针名->*类数据成员指针名					//访问类的数据成员

(对象名.*类成员函数指针名)(参数表)			//访问类的函数成员
(对象指针名->*类成员函数指针名)(参数表)			//访问类的函数成员
```
4. 指向类的静态成员的指针
对类的静态成员的访问是不依赖于对象的。因此，可以用普通的指针来指向和访问静态成员。
### 6.3 动态内存分配

动态内存分配可以使程序在运行过程中**按照实际需要申请适量的内存**，使用结束后还可以**释放**。申请和释放过程一般称为**建立**和**删除**，使用**new**和**delete**操作符

运算符new的功能是动态分配内存，或者动态的创建堆对象，语法形式如下：
```text
new 数据类型 (初始化参数列表)
```
如果内存申请成功，new运算便返回一个指向新分配内存首地址的类型的指针，可以通过这个指针访问堆对象；如果申请失败，会抛出异常
>在建立一个类的对象时，如果该类存在用户定义的默认构造函数，则"new T"和 "new T()"这两种写法的效果都是相同的。


运算符delete的功能是删除由new建立的对象，释放指针所指向的内存空间，语法形式如下：
```text
delete 指针名字
```
如果被删除的是对象，该对象的析构函数被调用，对于用new分配的内存，必须用delete加以释放，否则会导致动态分配的内存无法回收，使得程序占据的内存越来越大，这叫做**“内存泄露”**。

也可以创建数组类型的对象，语法形式为：
```text
new 类型名 [数组长度]
```

用new建立的数组，用delete删除的时候，指针名前要加上[]，语法形式为：
```text
delete[] 指针名字
```
动态生成一个整形数组，代码如下：
```c++
int *p=new int[10];
delete[] p;
```
用new也可以创建多维数组，形式如下：
```text
new 类型名T[数组第一维][数组第二维]...
```
其中第一维可以使任何结果的正整数的表达式，而其他各维数组长度必须是结果为正整数的常量表达式。如果申请成功返回一个纸箱新分配内存首地址的指针，但不是**T类型**，而是一个指向T类型数组的指针，数组元素个数为除最左边一维外各维的下标表达式的乘积。
```c++
float *fp = new float[10][25][10];//error

float (*fp)[25][10]=new float[10][25][10];//Ok
```
### 6.4 用vector创建数组对象
无论是静态数组，还是用new创建的动态数组，都难以检测下标越界的额错误。C++标准库提供了被封装的动态数组——**vector**，这种被封装的数组可以具有各种类型。**vector**是一个类模板，不是类。用vector定义动态数组的形式：   
```text
vector<元素类型>数组对象名(数组长度);	//用vector定义动态数组
```
用vector定义的数组对象的所有元素都会被初始化。另外，初值也可以自行指定，但只能为所有元素指定相同的初值：
```text
vector<元素类型>数组对象名(数组长度,元素初值);
```
访问vector数组对象的元素：
```text
数组对象名[下标表达式]	//访问vector数组对象的元素
```

### 6.5 深复制与浅复制
隐含的复制构造函数完成的只是浅复制。默认的复制构造函数将两个对象的对应数据简单复制后，也就是说两个指针指向的是同一内存地址，表面上好像完成了复制，但是并没有形成真正的副本。

浅复制还有更大的弊病，在程序结束之前对象的析构函数会自动被调用，动态分配的内存空间会被释放。由于两个对象共用了同一块内存空间，因此两次调用析构函数，将该内存空间释放了两次，于是导致运行错误。

解决“浅复制”问题的方法是编写复制构造函数，实现“深复制”。

### 6.6 字符串

C语言中用字符型数组来存放字符串，C++中依然可以沿用这一方法。不仅如此，C++标准库还预定义了string类。

#### 6.6.1 用字符数组存储和处理字符串

字符串常量是用一对双引号括起来的字符序列。在内存中按串中字符的排列次序顺序存放，每个字符占一个字节，并在末尾添加空字符（null character）’\0’作为结尾标记。这实际上是一个隐含创建的类型为char的数组，一个字符串常量就表示这样一个数组的首地址。因此，可以把字符串常量赋给字符串指针，由于常量值是不能修改的，所以应将字符串常量赋给指向常量的指针。

如果创建一个char数组，每个元素存放字符串的一个字符，在末尾放置一个’\0’，便构成了C++字符串。它的存储方式与字符串常量无异，但由于是程序员创建的数组，因此可以改变其内容，因而这就是字符串变量了。

对字符数组进行初始化赋值时，初值的形式可以是以逗号分隔的ASCII码或字符常量，也可以是整体的字符串常量（这时末尾的’\0’是隐含的）。下面三种创建字符串变量的写法等价：


字符常量用单引号括起；字符串常量用双引号括起，用双引号括起的字符串隐式地包含结尾的空字符。字符常量（如’S’）是字符串编码的简写表示，而”S”不是字符常量，它表示字符’S’和’\0’组成的字符串。

然而，用字符数组表示字符串后，执行很多字符串操作比较麻烦，需要借助**cstring**头文件中的字符串处理函数，比如**strcpy**函数（将一个字符串的内容复制到另一个字符串）、**strcat**函数（将两个字符串连接起来）、**strcmp**函数（按辞典顺序比较两个字符串的大小）。另外，当字符串长度很不确定时，需要用**new**来动态创建字符数组，最后还要用**delete**释放，这些都相当繁琐。

C++对这些繁琐的操作进行了封装，形成了string类，可以更加方便地操作字符串。

#### 6.6.2 string类

使用string类必须包含头文件string。string定义在命名空间std中。

严格地说，string并非一个独立的类，而是类模板basic_string的一个特定化实例。不过对使用者来说，其特点与一个类无异。

1. 构造函数的原型
```c++
string();//默认构造函数，建立一个长度为0的串
string(const string& rhs);//复制构造函数
string(const char *s);//用指针s所指的字符串常量初始化string类的对象
string(const string& rhs,unsigned int pos,unsigned int n);//将对象rhs中的串从位置pos开始n个字符，用来初始化string类的对象
string(const char *s,unsigned int n);//用指针s所指的字符串中的前n个字符初始化string类的对象
string(unsigned int n,char c);//将参数c中的字符重复n次，用来初始化string类的对象
```
2. string类的操作符
3. 常用成员函数功能简介